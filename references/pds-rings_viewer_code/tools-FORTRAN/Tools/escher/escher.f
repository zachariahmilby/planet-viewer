 
 
      SUBROUTINE ESCHER ( DEVICE, VIEW, FOV,   BEGIN,  END,    COLOR,
     .                    POSITN, FONT, FSIZE, FSCALE, BEGSEG, ENDSEG,
     .                    ERROR )
 
 
C$ Abstract
C
C     Draw segments generated by EUCLID.
C
C$ Required_Reading
C
C     ESCHER
C
C$ Keywords
C
C     GRAPHICS
C
C$ Declarations
 
      INTEGER               DEVICE
      DOUBLE PRECISION      VIEW   ( 4 )
      DOUBLE PRECISION      FOV    ( 4 )
 
      DOUBLE PRECISION      BEGIN  ( 3 )
      DOUBLE PRECISION      END    ( 3 )
      INTEGER               COLOR
 
      DOUBLE PRECISION      POSITN ( 3 )
      DOUBLE PRECISION      FONT   ( 2, 2, * )
      INTEGER               FSIZE
      DOUBLE PRECISION      FSCALE
 
      DOUBLE PRECISION      BEGSEG ( 3, * )
      DOUBLE PRECISION      ENDSEG ( 3, * )
 
      CHARACTER*(*)         ERROR
 
C$ Brief_I/O
C
C
C     VARIABLE  I/O  DESCRIPTION
C     --------  ---  ---------------------------------------------------
C     DEVICE     I   See ESVIEW, ESCLR
C     VIEW       I   See ESVIEW, ESCLR
C     FOV        I   See ESVIEW
C     BEGIN      I   See ESDRAW
C     END        I   See ESDRAW
C     COLOR      I   See ESDRAW
C     STAR       I   See ESSTAR
C     FONT       I   See ESSTAR
C     FSIZE      I   See ESSTAR
C     FSCALE     I   See ESSTAR
C     BEGSEG     O   See ESSTAR
C     ENDSEG     O   See ESSTAR
C     ERROR      O   Error flag used by all entry points.
C
C$ Detailed_Input
C
C      See entry points listed above.
C
C$ Detailed_Output
C
C      See entry points listed above.
C
C$ Parameters
C
      INTEGER               BSIZE
      PARAMETER           ( BSIZE  = 5000 )
C
C     BSIZE   is 5 times the number of segments that can be buffered
C             before shipping them out the ESCHERS segment drawing
C             routines.  This number MUST be a multiple of 5.  The
C             software makes explicit use of this assumption.
C
C$ Exceptions
C
C      See individual entry points.
C
C$ Particulars
C
C     ESCHER is the device handler for EUCLID. It accepts segments
C     (a segment consists of two endpoints and a color) from EUCLID,
C     clips them, buffers them internally (to cut down on I/O), and
C     then draws them on any of a number of supported graphics devices.
C
C     ESCHER has several entry points: ESVIEW, ESDRAW, ESDUMP, ESSTAR
C     and ESCLR. Each entry point is documented separately.
C
C     ESCHER is never called directly by the user.
C
C$ Examples
C
C     None.
C
C$ Files
C
C      None.
C
C$ Restrictions
C
C     ESCHER is just a cover for its entry points, and is never
C     called directly by the user.
C
C$ Literature References
C
C     None.
C
C$ Author_and_Institution
C
C     I.M. Underwood (JPL)
C     W.L. Taber     (JPL)
C
C$ Version_and_Date
C
C     Version 1, 22-JUL-1986
C     Version 2,  8-MAY-1990
C-
 
 
C
C     Spicelib Functions
C
      INTEGER               CARDI
      LOGICAL               ELEMI
 
C
C     Local Variables.
C
      DOUBLE PRECISION      BX
      DOUBLE PRECISION      BY
      DOUBLE PRECISION      EX
      DOUBLE PRECISION      EY
 
      DOUBLE PRECISION      FBOX   ( 4 )
      DOUBLE PRECISION      FIELD  ( 4 )
      DOUBLE PRECISION      FVIEW  ( 4 )
 
      DOUBLE PRECISION      HMIN
      DOUBLE PRECISION      HMAX
 
      DOUBLE PRECISION      INVUX
      DOUBLE PRECISION      INVUY
 
      DOUBLE PRECISION      L
      DOUBLE PRECISION      LCEN
      DOUBLE PRECISION      LINE
      DOUBLE PRECISION      LINE0
      DOUBLE PRECISION      LINE0T
      DOUBLE PRECISION      LINE1
      DOUBLE PRECISION      LINE1T
 
      DOUBLE PRECISION      P
      DOUBLE PRECISION      PCEN
      DOUBLE PRECISION      PIX0
      DOUBLE PRECISION      PIX0T
      DOUBLE PRECISION      PIX1
      DOUBLE PRECISION      PIX1T
      DOUBLE PRECISION      PIXEL
 
      DOUBLE PRECISION      TL
      DOUBLE PRECISION      TP
 
      DOUBLE PRECISION      U
      DOUBLE PRECISION      UX
      DOUBLE PRECISION      UY
 
      DOUBLE PRECISION      VMIN
      DOUBLE PRECISION      VMAX
      DOUBLE PRECISION      VUPORT ( 4 )
 
      DOUBLE PRECISION      X
      DOUBLE PRECISION      XCEN
      DOUBLE PRECISION      XMAX
      DOUBLE PRECISION      XMIN
 
      DOUBLE PRECISION      Y
      DOUBLE PRECISION      YCEN
      DOUBLE PRECISION      YMAX
      DOUBLE PRECISION      YMIN
 
 
C
C     Integer Array Control Parameters.
C
      INTEGER               LBCELL
      PARAMETER           ( LBCELL = -5 )
 
      INTEGER               NDEVS
      PARAMETER           ( NDEVS  = 99   )
 
      INTEGER               BOTTOM
      PARAMETER           ( BOTTOM = 3 )
 
      INTEGER               LEFT
      PARAMETER           ( LEFT   = 1)
 
      INTEGER               RIGHT
      PARAMETER           ( RIGHT  = 2 )
 
      INTEGER               TOP
      PARAMETER           ( TOP    = 4 )
 
 
      INTEGER               CLRLIM ( 4 )
      INTEGER               DUMMY  ( 4 )
      INTEGER               ESDEV
      INTEGER               I
      INTEGER               INITED ( LBCELL: NDEVS )
      INTEGER               J
      INTEGER               K
      INTEGER               N
      INTEGER               NBUF
      INTEGER               PIXLIN ( 4     )
      INTEGER               SEGBUF ( BSIZE )
 
 
      LOGICAL               INSIDE
      LOGICAL               FIRST
C
C     Device, viewport and image plane parameters.
C
      SAVE                  ESDEV
      SAVE                  VUPORT
      SAVE                  FIELD
 
C
C     Record of initialized devices.
C
      SAVE                  INITED
 
C
C     Limits for current display device.
C
C     LINE0,  will hold the minimum and maximum line numbers for the
C     LINE1   display device
C
C     PIX0,   will hold the minimum and maximum pixel values for the
C     PIX1    display device.
C
      SAVE                  LINE0
      SAVE                  LINE1
      SAVE                  PIX0
      SAVE                  PIX1
 
C
C     Segment buffer  BSIZE/5 is the maximum number of segments that
C                             can be buffered
C
C                     SEGBUF  is a cell containing segment endpoints
C                             and colors.
C
C                             SEGBUF(I*5-4) is the x-coordinate of the
C                                           beginning endpoint of the
C                                           I'th segment.
C
C                             SEGBUF(I*5-3) is the y-coordinate of the
C                                           beginning endpoint of the
C                                           I'th segment.
C
C                             SEGBUF(I*5-2) is the x-coordinate of the
C                                           ending endpoint of the
C                                           I'th segment.
C
C                             SEGBUF(I*5-1) is the y-coordinate of the
C                                           ending endpoint of the
C                                           I'th segment.
C
C                             SEGBUF(I*5  ) is the color for the I'th
C                                           segment.
C
      SAVE                  SEGBUF
      SAVE                  NBUF
 
 
 
C
C     Field of view limits supplied in ESVIEW.
C
      SAVE                  XMAX
      SAVE                  XMIN
      SAVE                  YMAX
      SAVE                  YMIN
 
C
C     Flag indicating if this is the first call to ESCHER
C
      SAVE                  FIRST
 
C
C     Initial Values.
C
      DATA                  ESDEV   / 0       /
      DATA                  FIRST   / .TRUE.  /
      RETURN
 
C
C$ Procedure ESVIEW
 
      ENTRY ESVIEW ( DEVICE, VIEW, FOV, ERROR )
 
C$ Abstract
C
C     Accept device, viewport, and field of view  parameters.
C
C$ Required Reading
C
C     ESCHER
C
C$ Brief_I/O
C
C     VARIABLE  I/O  DESCRIPTION
C     --------  ---  ---------------------------------------------------
C     DEVICE     I   Viewport device.
C     VIEW       I   Viewport area
C     FOV        I   Field of view
C     ERROR      O   Non-blank if inappropriate inputs are supplied.
C
C$ Detailed_Input
C
C     DEVICE     is the integer ID code for one of the devices supported
C                by ESCHER.
C
C     VIEW       is an array giving the boundaries of the rectangle that
C                will be used for the display of images.
C
C                VIEW(1)  are the horizontal boundaries of the display
C                VIEW(2)  rectangle.
C
C                VIEW(3)  are the vertical boundaries of the display
C                VIEW(4)  rectangle.
C
C     FOV        is an array giving the boundaries of the image plane
C                rectangle that will be mapped into the display
C                rectangle.
C
C                FOV(1)   are the limits on the x-values of points in
C                FOV(2)   the image plane.  A point in the image plane
C                         will be displayed only if its x-coordinate
C                         lies between these two values.
C
C                FOV(3)   are the limits on the y-values of points in
C                FOV(4)   the image plane.  A point in the image plane
C                         will be displayed only if its y-coordinate
C                         lies between these two values.
C
C$ Detailed_Output
C
C     ERROR      will be returned as a blank if no errors are detected.
C                Otherwise, it will contain a descriptive error message
C                indicating what event triggered the error (for example
C                an input device that does not exist, non-distinct
C                values for rectangle boundaries, or viewport values
C                outside the range from 0 to 1.)
C
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     1.) If the device supplied is not supported ERROR will be
C         returned with a message stating that the device is not
C         supported.
C
C     2.) If the values of VIEW are not between 0 and 1, the error
C         string will be returned with a message stating so.
C
C     3.) If either the horizontal or vertical boundaries of the
C         display viewport are the same ( VIEW(1) = VIEW(2) or
C         VIEW(3) = VIEW(4) respectively ) the error message
C         will indicate the problem.
C
C     4.) If either the x or y boundaries of the image plane rectangle
C         are the same ( FOV(1) = FOV(2) or FOV(3) = FOV(4)
C         respectively ) the error message will indicate the problem.
C
C$ Files
C
C     None.
C
C$ Particulars
C
C     EUCLID calls ESVIEW to tell ESCHER:
C
C            -  the device to be used.
C
C            -  the viewport in which to draw the segments passed
C               from EUCLID.
C
C            -  the field of view to be mapped onto the viewport.
C
C     Together, this information is needed to determine the mapping
C     from projection (x,y) space into the native pixel (pixel,line)
C     space of the viewport.
C
C     This routine should be called whenever, you need to change
C     the device, field of view or viewport.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     None.
C$ Literature References
C
C     None.
C
C$ Author_and_Institution
C
C     I.M. Underwood (JPL)
C     W.L. Taber     (JPL)
C
C$ Version_and_Date
C
C     Version 1, 22-JUL-1986
C     Version 2,  8-MAY-1990
C-
 
C
C     No errors so far.
C
      ERROR = ' '
 
      IF ( FIRST ) THEN
         CALL SSIZEI ( NDEVS, INITED )
         CALL SCARDI ( 0,     INITED )
         FIRST = .FALSE.
      END IF
 
C
C     When the view changes, all buffered segments are wiped out.
C
      NBUF = 0
 
C
C     Initialize the display device if it hasn't been already.
C
 
      IF ( .NOT. ELEMI( DEVICE, INITED ) ) THEN
 
         CALL ESDO    ( 'INITIATE', DEVICE, N, DUMMY, ERROR )
 
         IF ( ERROR .NE. ' ' ) THEN
            WRITE (*,*) ERROR
            RETURN
         END IF
 
         CALL INSRTI ( DEVICE, INITED )
 
      END IF
 
 
C
C     If you get this far, the device is at least O.K.  Record the
C     device number and mark it as being initialized.
C
      ESDEV         = DEVICE
 
C
C     Check that the viewport values are in bounds and that horizontal
C     and vertical pairs are distinct.
C
      DO I = 1, 4
         IF (( VIEW(I) .GT. 1.0D0 ) .OR. ( VIEW(I) .LT. 0.0D0 )) THEN
            ERROR = 'ESVIEW: Viewport values are out of range.'
            WRITE (*,*) ERROR
            RETURN
         END IF
      END DO
 
      IF (      (VIEW(1) .EQ. VIEW(2))
     .     .OR. (VIEW(3) .EQ. VIEW(4)) ) THEN
 
        ERROR = 'ESVIEW: Viewport edges are not distinct.'
        WRITE (*,*) ERROR
        RETURN
 
      END IF
 
      IF (      (FOV(1) .EQ. FOV(2))
     .     .OR. (FOV(3) .EQ. FOV(4)) ) THEN
 
        ERROR = 'ESVIEW: Field of view edges are not distinct.'
        WRITE (*,*) ERROR
        RETURN
 
      END IF
 
C
C     The field of view and viewport parameters are Ok. Store them for
C     use by other entry points.
C
      CALL MOVED  ( VIEW,   4, VUPORT )
      CALL MOVED  ( FOV,    4, FIELD  )
 
C
C     The clipping region is just the field of view.
C
      XMIN = FOV(1)
      XMAX = FOV(2)
      YMIN = FOV(3)
      YMAX = FOV(4)
 
C
C     Look up the line and pixel boundaries for this device
C     and set up the segment mapper.
C
      CALL ESDO    ( 'BOUNDS',   ESDEV, N, PIXLIN, ERROR )
 
      PIX0  = DBLE ( PIXLIN(1) )
      PIX1  = DBLE ( PIXLIN(2) )
      LINE0 = DBLE ( PIXLIN(3) )
      LINE1 = DBLE ( PIXLIN(4) )
 
      CALL ESMAP1  ( VUPORT, FIELD, PIX0, PIX1, LINE0, LINE1 )
 
      RETURN
 
C
C$ Procedure ESDRAW
 
      ENTRY ESDRAW ( BEGIN, END, COLOR, ERROR )
 
C$ Abstract
C
C     Draw a segment generated by EUCLID.
C
C$ Required Reading
C
C     ESCHER
C
C$ Brief_I/O
C
C     VARIABLE  I/O  DESCRIPTION
C     --------  ---  ---------------------------------------------------
C     BEGIN      I   Beginning point of the segment.
C     END        I   End point of the segment.
C     COLOR      I   Color index of the segment.
C     ERROR      O   Blank unless something goes wrong.
C
C$ Detailed_Input
C
C     BEGIN      is a vector giving the spacial position of the
C                starting endpoint of a line segment in 3-space.
C
C     END        is a vector giving the spacial positioon of the
C                ending endpoint of a line segment in 3-space.
C
C     COLOR      is an integer giving the color with which the line
C                segment should be drawn.
C
C$ Detailed_Output
C
C     ERROR      blank if no errors are detected.  Otherwise
C                a descriptive message giving the details of the
C                error will be returned.
C
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     None.
C
C$ Files
C
C     None.
C
C$ Particulars
C
C     Once the necessary clipping parameters and the mapping from
C     projection space to pixel space have been determined, EUCLID sends
C     segments to ESCHER one by one via ESDRAW. As each segment is
C     encountered, it is clipped, mapped to pixel space, and buffered.
C     When the buffer space is full, the segments are dumped to the
C     appropriate low-level vector routine.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     The first call to ESDRAW must be preceded by at least one
C     call to ESVIEW.
C
C$ Literature References
C
C     None.
C
C$ Author_and_Institution
C
C     I.M. Underwood (JPL)
C     W.L. Taber     (JPL)
C
C$ Version_and_Date
C
C     Version 1, 22-JUL-1986
C     Version 2,  8-MAY-1990
C-
C-
      IF ( ESDEV .EQ. 0 ) THEN
         ERROR = 'ESDRAW: A valid call to ESVIEW needs to be performed.'
         WRITE (*,*) ERROR
         RETURN
      END IF
 
C
C     In order to clip this pig, it needs to be transformed into
C     projection space.
C
      BX = - BEGIN(1) / BEGIN(3)
      BY = - BEGIN(2) / BEGIN(3)
 
      EX = - END(1)   / END(3)
      EY = - END(2)   / END(3)
 
C
C     The clipping routine will shorten the projected segment,
C     or eliminate it altogether, if it comes to that. If the
C     clipped segment is still inside the clipping area, map it
C     and load it into the buffer. If the buffer is full, ship it.
C
      CALL ESCLIP (   XMIN, XMAX, YMIN, YMAX,
     .                BX,   BY,   EX,   EY,    INSIDE )
 
 
C
C     Keep the segment only if it is inside the clipped region.
C
      IF ( INSIDE ) THEN
 
C
C        Map the segments to the line pixel pairs on the image
C        device.
C
         CALL ESMAP2 ( BX, BY, SEGBUF(1+NBUF), SEGBUF(2+NBUF) )
         CALL ESMAP2 ( EX, EY, SEGBUF(3+NBUF), SEGBUF(4+NBUF) )
 
C
C        Store the color
C
         SEGBUF(5+NBUF) = COLOR
 
C
C        Reset the cardinality of the cell.
C
         NBUF = NBUF + 5
 
      END IF
 
C
C     If the segment buffer is full ship them out to ESDO
C     which is supposed to know what to do with them.  Then
C     reset the cardinality of the segment buffer to 0.
C
      IF ( NBUF .EQ. BSIZE ) THEN
 
         N    = NBUF
         NBUF = 0

         CALL ESDO   ( 'DRAW', ESDEV, N, SEGBUF, ERROR )
  
      END IF
 
      RETURN
 
C
C$ Procedure ESDUMP
 
      ENTRY ESDUMP ( ERROR )
 
C$ Abstract
C
C     Dump the contents of ESCHER's segment buffer to the current
C     viewport.
C
C$ Required Reading
C
C     ESCHER
C
C$ Brief_I/O
C
C     VARIABLE  I/O  DESCRIPTION
C     --------  ---  ---------------------------------------------------
C     ERROR      O   Blank unless something goes wrong.
C
C$ Detailed_Input
C
C     None.
C
C$ Detailed_Output
C
C     ERROR      will be returned as a blank unless an error
C                is detected.  In that case it will be returned
C                with a message describing the problem.
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     None.
C
C$ Files
C
C     None.
C
C$ Particulars
C
C     Usually, the last segment in a scene will not cause the buffer
C     to fill. Calling ESDUMP causes any segments still in ESCHER's
C     SEGMENT buffer to be dumped to the current viewport.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     The first call to ESDUMP must be preceded by at least one
C     call to ESVIEW.
C
C$ Literature References
C
C     None.
C
C$ Author_and_Institution
C
C     I.M. Underwood (JPL)
C     W.L. Taber     (JPL)
C
C$ Version_and_Date
C
C     Version 1, 22-JUL-1986
C     Version 2,  8-MAY-1990
C-
 
C
C     Just ship the buffer, full or not.
C
      N    = NBUF
      NBUF = 0
 
      IF ( N .GT. 0 ) THEN
         CALL ESDO   ( 'DRAW', ESDEV, N, SEGBUF, ERROR )
      END IF
 
      RETURN
 
 
C
C$ Procedure ESCLR
 
      ENTRY ESCLR ( DEVICE, VIEW, ERROR )
 
C$ Abstract
C
C     Clear an ESCHER viewport.
C
C$ Required Reading
C
C     ESCHER
C
C$ Brief_I/O
C
C     VARIABLE  I/O  DESCRIPTION
C     --------  ---  ---------------------------------------------------
C     DEVICE     I   Viewport device.
C     VIEW       I   Viewport area
C     ERROR      O   Non-blank if inappropriate inputs are supplied.
C
C$ Detailed_Input
C
C     DEVICE     is the integer ID code for one of the devices supported
C                by ESCHER.
C
C     VIEW       is an array giving the boundaries of the rectangle that
C                will be used for the display of images.
C
C                VIEW(1)  are the horizontal boundaries of the display
C                VIEW(2)  rectangle.
C
C                VIEW(3)  are the vertical boundaries of the display
C                VIEW(4)  rectangle.
C
C$ Detailed_Output
C
C     ERROR      will be returned as a blank if no errors are detected.
C                Otherwise, it will contain a descriptive error message
C                indicating what event triggered the error (for example
C                an input device that does not exist, non-distinct
C                values for rectangle boundaries, or viewport values
C                outside the range from 0 to 1.)
C
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     1.) If the device supplied is not supported ERROR will be
C         returned with a message stating that the device is not
C         supported.
C
C     2.) If the values of VIEW are not between 0 and 1, the error
C         string will be returned with a message stating so.
C
C     3.) If either the horizontal or vertical boundaries of the
C         display viewport are the same ( VIEW(1) = VIEW(2) or
C         VIEW(3) = VIEW(4) respectively ) the error message
C         will indicate the problem.
C
C$ Files
C
C     None.
C
C$ Particulars
C
C     ESCLR clears any viewport. That is, any area of any device
C     supported by ESCHER.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     None.
C
C$ Literature References
C
C     None.
C
C$ Author_and_Institution
C
C     I.M. Underwood (JPL)
C     W.L. Taber     (JPL)
C
C$ Version_and_Date
C
C     Version 1, 22-JUL-1986
C     Version 2,  8-MAY-1990
C-
 
      ERROR = ' '
C
C     Make sure the device has been INITED
C
      IF ( FIRST ) THEN
         CALL SSIZEI ( NDEVS, INITED )
         CALL SCARDI ( 0,     INITED )
         FIRST = .FALSE.
      END IF
 
      IF ( .NOT. ELEMI (DEVICE, INITED ) ) THEN
 
         CALL ESDO ( 'INITIATE', DEVICE, N, DUMMY, ERROR )
 
         IF ( ERROR .NE. ' ' ) THEN
            WRITE (*,*) ERROR
            RETURN
         ELSE
            CALL INSRTI ( DEVICE, INITED )
         END IF
 
      END IF
 
C
C     Check that the viewport values are in bounds and that horizontal
C     and vertical pairs are distinct.
C
      DO I = 1, 4
         IF (( VIEW(I) .GT. 1.0D0 ) .OR. ( VIEW(I) .LT. 0.0D0 )) THEN
            ERROR = 'ESCLR: Viewport values are out of range.'
            WRITE (*,*) ERROR
            RETURN
         END IF
      END DO
 
      IF (      (VIEW(1) .EQ. VIEW(2))
     .     .OR. (VIEW(3) .EQ. VIEW(4)) ) THEN
 
        ERROR = 'ESCLR: Viewport edges are not distinct.'
        WRITE (*,*) ERROR
        RETURN
 
      END IF
 
C
C     Fetch the line pixel bounds for this device.
C
      CALL ESDO   ( 'BOUNDS', DEVICE, N, PIXLIN, ERROR )
 
      PIX0T  = DBLE ( PIXLIN(1) )
      PIX1T  = DBLE ( PIXLIN(2) )
      LINE0T = DBLE ( PIXLIN(3) )
      LINE1T = DBLE ( PIXLIN(4) )
 
C
C     Assign scratch variables.
C
      HMIN = MIN( VIEW(1), VIEW(2) )
      HMAX = MAX( VIEW(1), VIEW(2) )
      VMIN = MIN( VIEW(3), VIEW(4) )
      VMAX = MAX( VIEW(3), VIEW(4) )
 
C
C     Determine the pixel and line CLRLIM of the viewing area.
C
      CLRLIM (LEFT  )  = IDNINT ( PIX0T  + HMIN * (PIX1T  - PIX0T ) )
      CLRLIM (RIGHT )  = IDNINT ( PIX0T  + HMAX * (PIX1T  - PIX0T ) )
      CLRLIM (TOP   )  = IDNINT ( LINE0T + VMAX * (LINE1T - LINE0T) )
      CLRLIM (BOTTOM)  = IDNINT ( LINE0T + VMIN * (LINE1T - LINE0T) )
 
C
C     Now clear the device.
C
      CALL ESDO ( 'CLEAR',  DEVICE, N, CLRLIM, ERROR )
 
      RETURN
 
 
 
 
C
C$Procedure ESSTAR
 
      ENTRY ESSTAR ( POSITN, FONT,
     .               FSIZE,  FSCALE,
     .               BEGSEG, ENDSEG )
 
C$ Abstract
C
C     Determine the segments in 3-space that map to the supplied
C     character description.
C
C$ Required Reading
C
C     ESCHER
C
C$ Keyword
C
C     GRAPHICS
C
C$
 
 
C$ Brief_I/O
C
C     Variable  I/O  Description
C     --------  ---  --------------------------------------------------
C     POSITN     I   The position of a point in 3-space.
C     FONT       I   Line segments that describe a character.
C     FSIZE      I   The number of line segments per character.
C     FSCALE     I   How big to make the character.
C     BEGSEG     O   The starting endpoints of 3-space segments.
C     ENDSEG     O   The ending endpoints of 3-space segments.
C
C$ Detailed_Input
C
C     POSITN     The position of a point in 3-space that is to be marked
C                with a special character in an image.
C
C     FONT       Line segments that describe the character to mark the
C                segments with.  The beginning endpoint of the I'th
C                segment is given by
C
C                     ( FONT(1,1,I),
C                       FONT(2,1,I)  ).
C
C                The ending endpoint of the I'th segment is given by
C
C                     ( FONT(1,2,I),
C                       FONT(2,2,I)  )
C
C     FSIZE      The number of line segments per character.
C
C     FSCALE     How big to make the character.  This should be a number
C                between 0 and 1.  The size of the character will be
C                FSCALE times the size of the display viewport.
C
C$ Detailed_Output
C
C     BEGSEG     The starting endpoints of 3-space segments that will
C                map to the character described by FONT and FSCALE
C                on the display device.
C
C     ENDSEG     The ending endpoints of 3-space segments that will
C                map to the character described by FONT and FSCALE
C                on the display device.
C
C$ Parameters
C
C     None.
C
C$ Exceptions
C
C     None.
C
C$ Files
C
C     None.
C
C$ Particulars
C
C     Given a point in 3-space that will appear an image (as produced
C     by Euclid or some other program)  it is sometimes useful to
C     mark the point with a character.  This routine enables you to
C     create segments in 3-space that will map in a predictable way
C     to the image plane.  Moreover, if some of these segments lie
C     behind some object, they can be appropriately clipped.
C
C     Roughly here's what happens.
C
C        Let FIELD denote the image plane rectangle, VUPORT denote the
C        display viewport rectangle and let MAP be the mapping that
C        carries FIELD to VUPORT.  (Note that MAP is defined for the
C        entire image plane not just FIELD).  Let MAPINV be the inverse
C        mapping of MAP, that carries the plane containing the
C        viewport plane to the image plane.
C
C        The position of the point is mapped (using MAP) onto the
C        display plane.
C
C        A temporary viewport, FVIEW, centered about 0,0 is
C        constructed that is FSCALE times the size of the display
C        viewport VUPORT.
C
C        A temporary image rectangle, FBOX, is constructed that
C        contains the segments listed in FONT.
C
C        The segments in FBOX are mapped to TVIEW.
C
C        Using the same mapping as from FBOX to TVIEW the image
C        plane origin is mapped to the display plane, call the
C        image O.
C
C        The translation that caries O to the mapping of POSITN in the
C        display plane is applied to every segment in TVIEW.
C
C        MAPINV is applied to the endpoints of the translated segments
C        to map them back to image plane.
C
C        Finally, these image plane segments are inverse gnomonically
C        projected to segments in 3-space that are the same distance
C        from the pinhole of the projection as was the original point
C        given in POSITN.
C
C$ Examples
C
C     None.
C
C$ Restrictions
C
C     A call to ESINIT, and ESVIEW must have occurred prior to calling
C     this routine.
C
C$ Literature_References
C
C     None.
C
C$ Author_and_Institution
C
C     W.L. Taber     (JPL)
C     I.M. Underwood (JPL)
C
C$ Version
C
C-    Version 2,  10-MAY-1990 (WLT) (IMU)
C
C
C-&
 
C
C     Project the star to its position in the image plane
C
      X = - POSITN(1) / POSITN (3)
      Y = - POSITN(2) / POSITN (3)
 
C
C     Move the contents of VUPORT and FIELD to local variables.
C
      HMIN = VUPORT(1)
      HMAX = VUPORT(2)
      VMIN = VUPORT(3)
      VMAX = VUPORT(4)
 
C
C     Map (X,Y) to the appropriate line-pixel location of the imaging
C     device
C
C     Compute the mapping from the image plane to the display device
C     (without using ESMAP --- we want everything to stay in
C     Double Precision for now.  SEE ESMAP for details of what is going
C     on)
C
C     This mapping has the form:
C
C     X ---> P(X) =  CENTER(VUPORT)_pixel
C                 +  UX * ( X - CENTER(IMAGE RECTANGLE)_x )
C
C     Y ---> V(Y) =  CENTER(VUPORT)_line
 
 
C                 +  UY * ( Y - CENTER(IMAGE RECTANGLE)_y )
C
C
C     Determine the scaling factors.
C
      UX = (HMAX - HMIN) * ( PIX1  - PIX0  ) / (XMAX - XMIN)
      UY = (VMAX - VMIN) * ( LINE1 - LINE0 ) / (YMAX - YMIN)
 
      U  = MIN ( ABS (UX), ABS (UY) )
 
      UX = SIGN ( U, UX )
      UY = SIGN ( U, UY )
 
C
C     From the above we see that the inverse mapping from horizontal
C     vertical pairs (h,v) is given by:
C
C
C     P ---> X(P) =  CENTER(IMAGE RECTANGLE)_x
C                 +  (1/UX)*( H - CENTER(VUPORT)_pixel )
C
C     L ---> Y(L) =  CENTER(IMAGE RECTANGLE)_y
C                 +  (1/UY)*( V - CENTER(VUPORT)_line  )
C
C     Compute the inverse scaling factors.
C
      INVUX = 1.0D0 / UX
      INVUY = 1.0D0 / UY
 
C
C     Determine the center of the mapping regions, in both projection
C     and pixel/line spaces.
C
      XCEN = (XMIN + XMAX) / 2.D0
      YCEN = (YMIN + YMAX) / 2.D0
 
      PCEN = PIX0  + (HMAX + HMIN) * (PIX1  - PIX0 ) / 2.D0
      LCEN = LINE0 + (VMAX + VMIN) * (LINE1 - LINE0) / 2.D0
 
C
C     Now determine the point to which the point given by POSITN maps
C
      P    = PCEN  + UX * (X - XCEN)
      L    = LCEN  + UY * (Y - YCEN)
 
 
 
C
C     Determine the extremes of  the smallest box that contains the
C     current font.
C
      FBOX(1)    = FONT(1,1,1)
      FBOX(2)    = FONT(1,1,1)
      FBOX(3)    = FONT(2,1,1)
      FBOX(4)    = FONT(2,1,1)
 
      DO I = 1, FSIZE
         DO  J = 1, 2
            FBOX(1) = MIN ( FONT(1,J,I), FBOX(1) )
            FBOX(2) = MAX ( FONT(1,J,I), FBOX(2) )
            FBOX(3) = MIN ( FONT(2,J,I), FBOX(3) )
            FBOX(4) = MAX ( FONT(2,J,I), FBOX(4) )
         END DO
      END DO
 
C
C     Make sure that there is a true rectangle enclosing the font.
C
      IF ( FBOX(1) .EQ. FBOX(2) ) THEN
           FBOX(1) = FBOX(1) - 0.001
           FBOX(2) = FBOX(2) + 0.001
      END IF
 
      IF ( FBOX(3) .EQ. FBOX(4) ) THEN
           FBOX(3) = FBOX(3) - 0.001
           FBOX(4) = FBOX(4) + 0.001
      END IF
 
C
C     Create a fake image region into which the font will be mapped
C     The size is determined by the size of the current mapping region
C     and the parameter FSCALE.
C
 
      FVIEW (1) =   - FSCALE * 0.5D0 * DABS(   VUPORT(2)
     .                                       - VUPORT(1) )
 
      FVIEW (2) =   + FSCALE * 0.5D0 * DABS(   VUPORT(2)
     .                                       - VUPORT(1) )
 
      FVIEW (3) =   - FSCALE * 0.5D0 * DABS(   VUPORT(4)
     .                                       - VUPORT(3) )
 
      FVIEW (4) =   + FSCALE * 0.5D0 * DABS(   VUPORT(4)
     .                                       - VUPORT(3) )
 
C
C     Set up ESMAP for drawing segments in the region given by FVIEW.
C     (We will reset ESMAP by calling it once we are done mapping all
C     of the segments.)
C
      CALL ESMAP1 ( FVIEW, FBOX, PIX0, PIX1, LINE0, LINE1 )
 
C
C     Determine where the center of the FONT maps to
C
      CALL ESMAP2 ( 0.0D0, 0.0D0, J, K )
 
C
C     Subtract the center of the font from (P,L) to get the translation
C     that we need to apply to the endpoints of FONT to get them
C     from FVIEW to the point in the diplay plane they are marking.
C
      TP = P - DFLOAT(J)
      TL = L - DFLOAT(K)
 
C
C     Now map each of the segments in FONT into the prepared
C     region.  Then translate these segments so that they will
C     be centered about the current position.
C
      DO I = 1, FSIZE
 
C
C        Map the beginning endpoint of the segment from FBOX
C        into the display plane.
C
         CALL ESMAP2 ( FONT(1, 1, I), FONT(2, 1, I), J, K )
 
         PIXEL          = TP   + DFLOAT (J)
         LINE           = TL   + DFLOAT (K)
 
C
C        Map the display position back into 3-dimensional space.
C
         X              = XCEN + ( ( PIXEL - PCEN ) * INVUX )
         Y              = YCEN + ( ( LINE  - LCEN ) * INVUY )
 
         BEGSEG( 1, I ) = - X  * POSITN(3)
         BEGSEG( 2, I ) = - Y  * POSITN(3)
         BEGSEG( 3, I ) =        POSITN(3)
 
C
C        Map the ending endpoint of the segment from FBOX
C        into the display plane.
C
         CALL ESMAP2 ( FONT(1, 2, I), FONT(2, 2, I), J, K )
 
         PIXEL          = TP   + DFLOAT (J)
         LINE           = TL   + DFLOAT (K)
 
C
C        Map the display device position back into 3-dimensional space.
C
         X              = XCEN + ( ( PIXEL - PCEN ) * INVUX )
         Y              = YCEN + ( ( LINE  - LCEN ) * INVUY )
 
         ENDSEG( 1, I ) = - X  * POSITN(3)
         ENDSEG( 2, I ) = - Y  * POSITN(3)
         ENDSEG( 3, I ) =        POSITN(3)
 
      END DO
 
C
C     Reset ESMAP for normal image plane mapping.
C
      CALL ESMAP1 ( VUPORT, FIELD, PIX0, PIX1, LINE0, LINE1 )
 
 
      RETURN
      END
 
 
 
